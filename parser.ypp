%{
	#include <iostream>
	#include <stdlib.h>
    #include "output.hpp"
    #include "structs.h"
    #include "tableStack.h"
    #include "semantic.h"
	using namespace std;
	using namespace output;
	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	TableStack *symbolTable;
	int yyerror(const char * message);
	#define YYSTYPE Types
%}
%union Types{
     int Integer;
     bool Boolean;
     types Type;
     string Str;
     EnumClass EnumClass;
     Call Call;
     Expression Exp;
     NamedExpression NamedExp;
};
%type <Exp> Exp
%type <Type> Type
%type <Funcs> Funcs
%type <FuncDecl> FuncDecl
%type <Enums> Enums
%type <EnumDecl> EnumDecl
%type <RetType> RetType
%type <Formals> Formals
%type <FormalsList> FormalsList
%type <FormalDecl> FormalDecl
%type <EnumeratorList> EnumeratorList
%type <Enumerator> Enumerator
%type <Statements> Statements
%type <Statement> Statement
%type <Call> Call
%type <ExpList> ExpList
%type <Type> Type
%type <EnumType> EnumType
%type <Exp> Exp

%token <Str> BOOL VOID
%token <EnumClass> ENUM
%token <Integer> INT BYTE B
%token <Str> TRUE FALSE
%token <Str> WHILE RETURN
%token <Str> BREAK CONTINUE
%token <Str> SC COMMA
%token <Str> STRING ID
%token <Integer> NUM

%right <Str> ASSIGN
%nonassoc NO_ELSE
%nonassoc <Str> ELSE
%right <Str> IF
%left <Str> OR
%left <Str> AND
%left <Str> EQUALITY
%nonassoc <Str> LHSS
%nonassoc <Str> RHSS
%left <Str> ADDITIVE
%left <Str> MUL
%right <Str> NOT
%left <Str> LPAREN RPAREN LBRACE RBRACE

%%

Program : Enums Funcs { printProductionRule(1); }
    ;

Funcs : %empty { printProductionRule(2); }
    | FuncDecl Funcs { printProductionRule(3); }
    ;

FuncDecl : RetType ID InsertDecl LPAREN Formals RPAREN  LBRACE NewScope Statements RBRACE { printProductionRule(4); }
    ;

InsertDecl : %empty {
                        if (!symbolTable) symbolTable = new TableStack;
                        symbolTable->newVar((string)yytext,
                    }

Enums : %empty { printProductionRule(5); }
    | EnumDecl Enums { printProductionRule(6); }
    ;

EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC { printProductionRule(7); }
    ;

RetType : Type { printProductionRule(8); }
    | VOID { currRetType = VOID }
    ;

Formals : %empty { printProductionRule(10); }
    | FormalsList { printProductionRule(11); }
    ;

FormalsList : FormalDecl { printProductionRule(12); }
    | FormalDecl COMMA FormalsList { printProductionRule(13); }
    ;

FormalDecl : Type ID InsertDecl { printProductionRule(14); }
    | EnumType ID { printProductionRule(15); }
    ;

EnumeratorList : Enumerator { printProductionRule(16); }
    | EnumeratorList COMMA Enumerator { printProductionRule(17); }
    ;

Enumerator : ID { printProductionRule(18); }
    ;

Statements : Statement { printProductionRule(19); }
    | Statements Statement { printProductionRule(20); }
    ;

Statement : LBRACE NewScope Statements RBRACE { printProductionRule(21); }
    | Type ID SC { printProductionRule(22); }
    | EnumType ID SC { printProductionRule(23); }
    | EnumDecl { printProductionRule(24); }
    | Type ID ASSIGN Exp SC { printProductionRule(25); }
    | EnumType ID ASSIGN Exp SC { printProductionRule(26); }
    | ID ASSIGN Exp SC { printProductionRule(27); }
    | Call SC { printProductionRule(28); }
    | RETURN SC { printProductionRule(29); }
    | RETURN Exp SC { printProductionRule(30); }
    | IF LPAREN Exp RPAREN Statement %prec NO_ELSE { printProductionRule(31); }
    | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(32); }
    | WHILE LPAREN Exp RPAREN Statement { printProductionRule(33); }
    | BREAK SC { printProductionRule(34); }
    | CONTINUE SC { printProductionRule(35); }
    ;

NewScope : %empty {
                        if (!symbolTable) symbolTable = new TableStack;
                        symbolTable->newScope();
                   }

Call : ID LPAREN ExpList RPAREN { printProductionRule(36); }
    | ID LPAREN RPAREN { printProductionRule(37); }
    ;

ExpList : Exp { printProductionRule(38); }
    | Exp COMMA ExpList { printProductionRule(39); }
    ;

Type : INT { currRetType = "int"; }
    | BYTE { currRetType = "byte"; }
    | BOOL { currRetType = "bool"; }
    ;

EnumType : ENUM ID { printProductionRule(43); }
    ;

Exp : LPAREN Exp RPAREN { $$.Exp.val = $2.Exp.val;
                          $$.Exp.type = $2.Exp.type; }
    | Exp ADDITIVE Exp { if($2.str == "+")
                             $$.Exp.val = $1.Exp.val + $3.Exp.val;
                         else
                             $$.Exp.val = $1.Exp.val - $3.Exp.val; }
    | Exp MUL Exp { if($2.str == "*")
                        $$.Exp.val = $1.Exp.val * $3.Exp.val;
                    else
                        $$.Exp.val = $1.Exp.val / $3.Exp.val;}
    | ID { $$.Exp.name = $1.str; }
    | Call { printProductionRule(47); }
    | NUM { $$.Exp.val = yylval.value;
            $$.Exp.type = INT; }
    | NUM B { $$.Exp.val = yylval.value;
              $$.Exp.type = BYTE; }
    | STRING { $$.Exp.val = yylval.str;
               $$.Exp.type = STRING;  }
    | TRUE { $$.Exp.val = yylval.value;
             $$.Exp.type = BOOL;  }
    | FALSE { $$.Exp.val = yylval.value;
              $$.Exp.type = BOOL; }
    | NOT Exp { $$.Exp.val = !yylval.value;
                $$.Exp.type = BOOL; }
    | Exp AND Exp { if($1.Exp.isBool() && $3.Exp.isBool()){
                        $$.Exp.val = $1.Exp.val && $3.Exp.val;
                        $$.Exp.type = BOOL:
                  }  else
                        void errorSyn(yylineno);
                  }
    | Exp OR Exp { if($1.Exp.isBool() && $3.Exp.isBool());
                       $$.Exp.val = $1.Exp.val || $3.Exp.val;
                   else
                       errorSyn(yylineno);
                 }
    | Exp EQUALITY Exp { if (($1.Exp.type == INT && $3.Exp.type == INT) || ($1.Exp.type == BYTE && $3.Exp.type == BYTE) {
                            $$.type = BOOL;
                            $$.val = ($1.Exp.val == $3.Exp.val);
                         } else
                            errorSyn(yylineno);
                       }
    | Exp RHSS Exp { if (($1.Exp.type == INT && $3.Exp.type == INT) || ($1.Exp.type == BYTE && $3.Exp.type == BYTE) {
                        $$.type = BOOL;
                        $$.val = ($1.Exp.val == $3.Exp.val);
                     } else
                        errorSyn(yylineno);
                   }
    | Exp LHSS Exp { if (($1.Exp.type == INT && $3.Exp.type == INT) || ($1.Exp.type == BYTE && $3.Exp.type == BYTE) {
                        $$.type = BOOL;
                        $$.val = ($1.Exp.val == $3.Exp.val);
                     } else
                        errorSyn(yylineno);
                   }
    | LPAREN Type RPAREN Exp {  if ($4.Exp.isEnum() && $2.type == INT) {

                                }
                             }
    ;
%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
    if (yylval == 1) errorLex(yylineno);
	else errorSyn(yylineno);
	exit(0);
}
